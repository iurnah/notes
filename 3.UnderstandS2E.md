S2E source code
===
####Table of contenst:

- [How to Write an S2E plugin?](#HowtoS2EPlugin)
   - [AlienDetector Example](#AlienDetector) _simplest runable example to understand signal and slot._
   - [InstructionTracker.h](#InstructionTracker.h) _s2e tutorial "How to Write an S2E Plugin?" complete code._
- [CorePlugin.h](#CorePlugin.h) _declaration of signals, i.e `onModuleExecution`_
- [CorePlugin.cpp](#CorePlugin.cpp) _definition of functions called from QEMU to trigger emit_
- [BaseInstructions.h](#BaseInstructions.h)
- [BaseInstructions.cpp](#BaseInstructions.cpp) _s2e basic functionalities, `makeSybolic()` etc._ 
- [OSMonitor.h](#OSMonitor.h) _define signals such as `onModuleLoad`, `onProcessUnload`, and member functions such as `getImports()`, `getCurrentStack()`._
- [RawMonitor.h](#RawMonitor.h) class inherited from `OSMonitor`, include `struct Cfg`
- [RawMonitor.cpp](#RawMonitor.cpp) _emit signal after load module succesfully in `loadModule` and `opLoadModule`._
- [Example: onCustomInsruction](#Example: onCustomInsruction) How the onCustomInsruction signal is emitted?)
- [ModuleExecutionDetector.h](#ModuleExecutionDetector.h)
- [ModuleExecutionDetector.cpp](#ModuleExecutionDetector.cpp) _function to read configured module info, define `moduleLoadListener`, `onTranslationBlockStart` member functions. `class ModuleTransitionState`.
- [init_env.c](#init_env.c) guest tool.
- [CodeSelector.h](#CodeSelector.h)
- [CodeSelector.cpp](#CodeSelector.cpp)
- [ExecutionTracer.h](#ExecutionTracer.h)
- [ExecutionTracer.cpp](#ExecutionTracer.cpp)_create ExecutionTracer.dat file, each write is encapsulated in an ExecutionTraceItem before written to disk._
- [ModuleTracer.h](#ModuleTracer.h) _`class ModuleTracerState`, and `addModule`, `getCurrentModule` meber functions._
- [ModuleTracer.cpp](#ModuleTracer.cpp) _also define the memeber function `moduleLoadListener`, find out the difference between it and `ModuleExecutionDetector.cpp`_
- [ModuleDescriptor.h](#ModuleDescriptor.h) only included in `RawMonitor.h`, `OSMonitor.h`, `MemoryChecker.cpp`, and `ModuleExecutionDetector.h`
- [.cpp](#.cpp)
- [.h](#.h)
- [S2E.h](#S2E.h)
- [S2E.cpp](#S2E.cpp)
- [References](#reference)

<a name="HowtoS2EPlugin" />
## How to Write an S2E plugin

- Plugin - count how many times a specific instruction has been executed.
- configuration file - specify which instruction to watch.
- communication - with other plugins and expose reusable functionality.

The example gives the template for writing a plugin. Several things to understand:

1. Reading configuration parameters
2. Register callback with signals

For 1. there is a code snippets that read the value from the configuration file.
```cpp
//...

void InstructionTracker::initialize()
{
    m_address = (uint64_t) s2e()->getConfig()->getInt(getConfigKey() + ".addressToTrack");
}
```

Here noticed the ".addressToTrack" string is the name of the configured value in the config file.

For 2. You need to understand how signal works and how the callback parameters is passed. Let's see a very simple exaple of signal and callback from the [tutorial of sigc++][alienDetector]

<a name="AlienDetector" />
### AlientDetector Example
```cpp
#include <iostream>
#include <string>
#include <sigc++/sigc++.h>
using namespace std;

//define the object that emit the signal
class AlienDetector
{
public:
	AlienDetector();

	void run();

	sigc::signal<void> signal_detected;
	sigc::signal<void, std::string> signalx_detected;
	sigc::signal<void, std::string, std::string> signaly_detected;
};

//Constructor
AlienDetector::AlienDetector(){}

//Member function that going to be emit signal
void AlienDetector::run()
{
	sleep(3);
	signal_detected.emit();
	signalx_detected.emit("grage");
	signaly_detected.emit("Polar Bear", "basement");
}

/****************************************************************************************************/
//Sophisticated alien alerter class
class AlienAlerter: public sigc::trackable
{
public:
	AlienAlerter(char const* servername);
	void alert();
	void alert2(string name, string where);
private:

};

//Constructor
AlienAlerter::AlienAlerter(char const*){}

//Member function as callback function. no parameters. 
void AlienAlerter::alert()
{
	cout << "sigc::mem_fun# AlienAlerter::alert() \n" 
	     << "There are aliens in the car park!" << endl;
}

//Member function as callback function. with two parameters. 
void AlienAlerter::alert2(string name, string where)
{
	cout << "sigc::mem_fun# AlienAlerter::alert(string, string) \n" 
	     << "There are " << name << " in the " << where << "!" << endl;
}

/****************************************************************************************************/
//Stand alone alert function that take one parameter.
void alerter(string where)
{
	cout << "sigc::ptr_fun# alerter() \n" << "There are aliens in the " 
	     << where << "!" << endl;
}

//Client function that connect to the signal and trigger the callback function
//call by run a demo member function from the object. 
int main()
{
	AlienDetector mydetector;
	AlienAlerter myalerter("localhost");
	
	//Connect to the signal that just invoke a stand alone function as a
	//callback, and there are not parameters. 
	mydetector.signalx_detected.connect(sigc::ptr_fun(alerter));

	//Connect to the signal that passing a string as a parameter. The
	//parameter is passed by the operator() or emit(). In other words, the
	//parameter passed to the emit() or operator() shoud mach the define of the
	//signal. 
	mydetector.signal_detected.connect(sigc::mem_fun(myalerter, &AlienAlerter::alert));

	//Connect to the signal that passing two string as parameters.
	mydetector.signaly_detected.connect(sigc::mem_fun(myalerter, &AlienAlerter::alert2));

	mydetector.run();
	
	return 0;
}
```
Above code can be compiled using the following command line:

```bash
g++ example1.cc -o example1 `pkg-config --cflags --libs sigc++2.0`
```

There are several points need to be remembered to understand signal and slot.

1. Define signals inside an object that want to emit signal when certain conditions are met.
- Connect a signal to slot(callbacks) in the initialize process.
- Client code that trigger the emit of the particular signal.
- Callback parameters could be declared in the signal declaration.
- The parameter passed to the callback by the emit() member function or overloaded operator().

<a name="InstructionTracker.h" />
## InstructionTracker.h

Let's coming back to S2E's plugin implementation. From the Plugin tutorial, I completed the following code: for `InstructionTracker.h` and `InstructionTracker.cpp`.

The header of InstructionTracker Plugin:
```cpp
#ifndef S2E_PLUGINS_INSTRTRACKER_H
#define S2E_PLUGINS_INSTRTRACKER_H

#include <s2e/Plugin.h>
#include <s2e/Plugins/CorePlugin.h>
#include <s2e/S2EExecutionState.h>

namespace s2e {
namespace plugins {
	
class InstructionTracker: public Plugin
{
	S2E_PLUGIN
	uint64_t m_address;
public:
	InstructionTracker(S2E *s2e): Plugin(s2e) {	}
	sigc::signal<void, S2EExecutionState *, uint64_t> onPeriodicEvent;
	
	void initialize();
	void onInstructionExecution(S2EExecutionState *state, uint64_t pc);
	void onTranslateInstruction(ExecutionSignal *signal, S2EExecutionState *state,
								TranslationBlock *tb, uint64_t pc);
};

}	//namespace plugins
}	//namespace s2e

//Plugin State for per state plugin information.
class InstructionTrackerState: public PluginState
{
    int m_count;

public:
    InstructionTrackerState() {
        m_count = 0;
    }

    ~InstructionTrackerState() {}

    static PluginState *factory(Plugin*, S2EExecutionState*) {
        return new InstructionTrackerState();
    }

    InstructionTrackerState *clone() const {
        return new InstructionTrackerState(*this);
    }

    void increment() { ++m_count; }
    int get() { return m_count; }

};
#endif
```

The Implementation of the InstructionTracker Plugin(InstructionTracker.cpp):
```cpp
#include <s2e/S2E.h>
#include "InstructionTracker.h"

namespace s2e {
namespace plugins {

//Define a plugin whose class is InstructionTracker and called "InstructionTracker".
//The plugin does not have any dependency.
S2E_DEFINE_PLUGIN(InstructionTracker, "Tutorial - Tracking instructions", "InstructionTracker",);

void InstructionTracker::initialize()
{
    m_address = (uint64_t) s2e()->getConfig()->getInt(getConfigKey() + ".addressToTrack");

	//This indicates that our plugin is interested in monitoring instruction translation.
    //For this, the plugin registers a callback with the onTranslateInstruction signal.
    s2e()->getCorePlugin()->onTranslateInstructionStart.connect(
        sigc::mem_fun(*this, &InstructionTracker::onTranslateInstruction));
}

void InstructionTracker::onTranslateInstruction(ExecutionSignal *signal,
												S2EExecutionState *state,
												TranslationBlock *tb,
												uint64_t pc);
{
    if(m_address == pc) {
        //When we find an interesting address, ask S2E to invoke our
        //callback when the address is actually executed.
        signal->connect(sigc::mem_fun(*this, &InstructionTracker::onInstructionExecution));
    }
}

//This callback is called only when the instruction at our address is executed.
//The callback incurs zero overhead for all other instructions.
void InstructionTracker::onInstructionExecution(S2EExecutionState *state, uint64_t pc)
{
    DECLARE_PLUGINSTATE(InstructionTrackerState, state);
    //This declaration will return the plgState object of type InstructionTrackerState. 

    s2e()->getDebugStream() << "Executing instruction at " << hexval(pc) << '\n';
    //The plugins can arbitrarily modify/observe the current execution state via
    //the execution state pointer.
    //Plugins can also call the s2e() method to use the S2E API.
    plgState->increment();

    //Fire the event
    if((plgState->get() % 10) == 0) {
	onPeriodicEvent.emit(state, pc);
    }
}

} // namespace plugins
} // namespace s2e
```
There need a client to run this plugin and trigger the emit of signal. We can see the s2e as the client. It is the `main` function.

####PluginState

The tutorial describe how to keep per-state plugin information in class `PluginState{}`. That is: the plugin works for each path independently. Two member function are needed. One for creating a new instance of the specific `PluginState` when s2e start symbolic execution. The other is a clone method that s2e used to fork plugin state when forking execution states during the execution. S2E automatically fork user code state when a new branch need to execute for the application, Plugin State have to be forked manually in the meantime by us.


<a name="CorePlugin.h" />
## CorePlugin.h

Declared all the signals that available to be connected by plugins. For example:

```cpp
    /** Signal that is emitted on beginning and end of code generation
        for each QEMU translation block.
    */
	onTranslateBlockStart;

    /* Signal that is emitted upon end of translation block */
	onTranslateBlockEnd;

    /* Signal that is emitted on code generation for each instruction */	
	onTranslateInstructionStart, onTranslateInstructionEnd;

    /*
     *  Triggered *after* each instruction is translated to notify
     *  plugins of which registers are used by the instruction.
     *  Each bit of the mask corresponds to one of the registers of
     *  the architecture (e.g., R_EAX, R_ECX, etc).
     */
	onTranslateRegisterAccessEnd;

    /* Signal that is emitted on code generation for each jump instruction */
	onTranslateJumpStart;

    /* Signal that is emitted upon exception */
	onException;

    /* Signal that is emitted when custom opcode is detected */
	onCustomInstruction;

    /* Signal that is emitted on each memory access */
    /* XXX: this signal is still not emitted for code */
	onDataMemoryAccess;

    /* Signal that is emitted on each port access */
	onPortAccess;

    sigc::signal<void> onTimer;

    /* Signal emitted when the state is forked */
	onStateFork;

	onStateSwitch;

    /* Triggered when S2E wants to generate a test case */
	onTestCaseGeneration;

    /* Triggered whenever a state is killed */
	onStateKill;

    /* Signal emitted when spawning a new S2E process */
	onProcessFork;

    /**
     * Signal emitted when a new S2E process was spawned and all
     * parent states were removed from the child and child states
     * removed from the parent.
     */
	onProcessForkComplete;


    /** Signal that is emitted upon TLB miss */
	onTlbMiss;

    /** Signal that is emitted upon page fault */
	onPageFault;

    /** Signal emitted when QEMU is ready to accept registration of new devices */
	onDeviceRegistration;

    /** Signal emitted when QEMU is ready to activate registered devices */
	onDeviceActivation;
	
	onPciDeviceMappingUpdate;

    /**
     * The current execution privilege level was changed (e.g., kernel-mode=>user-mode)
     * previous and current are privilege levels. The meaning of the value may
     * depend on the architecture.
     */
	onPrivilegeChange;

    /**
     * The current page directory was changed.
     * This may occur, e.g., when the OS swaps address spaces.
     * The addresses correspond to physical addresses.
     */
	onPageDirectoryChange;

    /**
     * S2E completed initialization and is about to enter
     * the main execution loop for the first time.
     */
	onInitializationComplete;

    /**
     * S2E has just received a command from QEMU's
     * QMP monitor interface. The dictionnary contains
     * the S2E-specific command parameters.
     */
	onMonitorCommand;

    /**
     * Fired when QEMU generates en event.
     * onMonitorEvent allows plugins to react to them by
     * sending back some data that will be serialized over
     * the QEMU monitor interface (e.g., to JSON).
     */
	onMonitorEvent;
```

Here pay attention to the signal `onCustomInstruction`. A lot of places have used it to run the `opLoadModule()`. There is always another version of this function such as `LoadModule()`.

<a name="CorePlugin.cpp" />
## CorePlugin.cpp

Define various function called by QEMU events to emit signals. For example:

```cpp
void s2e_tcg_execution_handler(void* signal, uint64_t pc)
{
    try {
        ExecutionSignal *s = (ExecutionSignal*)signal;
        if (g_s2e_enable_signals) {
            s->emit(g_s2e_state, pc);
        }
    } catch(s2e::CpuExitException&) {
        s2e_longjmp(env->jmp_env, 1);
    }
}
```

<a name="BaseInstructions.h" />
## BaseInstructions.h

<a name="BaseInstructions.cpp" />
## BaseInstructions.cpp

This file implement the following functions declared in header file. They are the majority of S2E functionality implementations, such as `makeSymbolic`, `killState`, etc.

```cpp
    void handleBuiltInOps(S2EExecutionState* state, uint64_t opcode);
    void onCustomInstruction(S2EExecutionState* state, uint64_t opcode);
    void invokePlugin(S2EExecutionState *state);
    void makeSymbolic(S2EExecutionState *state, bool makeConcolic);
    void isSymbolic(S2EExecutionState *state);
    void killState(S2EExecutionState *state);
    void printExpression(S2EExecutionState *state);
    void printMessage(S2EExecutionState *state, bool isWarning);
    void printMemory(S2EExecutionState *state);
    void concretize(S2EExecutionState *state, bool addConstraint);
    void sleep(S2EExecutionState *state);
    void assume(S2EExecutionState *state);
```

There are another object defined in this `BaseInstruction.cpp`, which is `class BaseInstructionPluginInvokeInterface`.

<a name="OSMonitor.h" />
## OSMonitor.h
> Base class for default OS actions. It provides an interface for loading/unloading modules > and processes.
> Note: several events use ModuleDescriptor as a parameter. The passed reference is valid 
> only during the call. Do not store pointers to such objects, but make a copy instead.

It defined The following Signals:
```cpp
public:
   sigc::signal<void, S2EExecutionState*, const ModuleDescriptor &> onModuleLoad;
   sigc::signal<void, S2EExecutionState*, const ModuleDescriptor &> onModuleUnload; //used in WindowsMonitor Plugin
   sigc::signal<void, S2EExecutionState*, const ThreadDescriptor&> onThreadCreate;  //used in WindowsMonitor Plugin
   sigc::signal<void, S2EExecutionState*, const ThreadDescriptor&> onThreadExit;    //used in WindowsMonitor Plugin
   sigc::signal<void, S2EExecutionState*, uint64_t> onProcessUnload; //used in WindowsMonitor Plugin
```
It also define the following virtual Functions:
```cpp
virtual bool getImports(S2EExecutionState *s, const ModuleDescriptor &desc, Imports &I) = 0;
virtual bool getExports(S2EExecutionState *s, const ModuleDescriptor &desc, Exports &E) = 0;
virtual bool isKernelAddress(uint64_t pc) const = 0;
virtual uint64_t getPid(S2EExecutionState *s, uint64_t pc) = 0;
virtual bool getCurrentStack(S2EExecutionState *s, uint64_t *base, uint64_t *size) = 0;
bool isOnTheStack(S2EExecutionState *s, uint64_t address); //which is use the prototype of getCurrentStacks() above.
```

<a name="RawMonitor.h" />
## RawMonitor.h

Didn't define new signals, only inherited from [`OSMonitor.h`](#OSMonitor.h).

<a name="RawMonitor.cpp" />
## RawMonitor.cpp

It establish two signal connections	 in the `RawMonitor::initialize()` function:
```cpp
m_onTranslateInstruction = s2e()->getCorePlugin()->onTranslateInstructionStart.connect(
        sigc::mem_fun(*this, &RawMonitor::onTranslateInstructionStart));
s2e()->getCorePlugin()->onCustomInstruction.connect(
            sigc::mem_fun(*this, &RawMonitor::onCustomInstruction));
```
Implement the member functions including `loadModule()` and `opLoadModule()`. In fact `loadModule()` is called from anothe member function `RawMonitor::onTranslateInstructionStart()`. the reason of doing this is because it automatically detect the module has been loaded by the onTranslateInstructionStart events. 
```cpp
void RawMonitor::loadModule(S2EExecutionState *state, const Cfg &c, bool skipIfDelay)
{
    ModuleDescriptor md;
    if (c.delayLoad && skipIfDelay) {
        return;
    }
    md.Name = c.name;
    md.NativeBase = c.nativebase;
    md.LoadBase = c.start;
    md.Size = c.size;
    md.Pid = c.kernelMode ? 0 : state->getPid();
    md.EntryPoint = c.entrypoint;

    s2e()->getDebugStream() << "RawMonitor loaded " << c.name << " " <<
            hexval(c.start) << ' ' << hexval(c.size) << '\n';
    onModuleLoad.emit(state, md);
}

void RawMonitor::onTranslateInstructionStart(ExecutionSignal *signal,
                                                   S2EExecutionState *state,
                                                   TranslationBlock *tb,
                                                   uint64_t pc)
{
    CfgList::const_iterator it;

    for (it = m_cfg.begin(); it != m_cfg.end(); ++it) {
        const Cfg &c = *it;
        loadModule(state, c, true);
    }

    m_onTranslateInstruction.disconnect();
}
```
In the `RawMonitor::initialize()` function, the `onTranslateInstructionStart` signal is connected, this signal is emitted upon code generation for each instruction Translation. In order to detect the module load, we can emit the `onModuleLoad.emit()` signal once the first code generation instruction will start (onTranslateInstructionStart), we then immediately disconnect the signal, future emition of `onTranslateInstructionStart` will not take any effect.

Thusly, we can summarize what the RawMonitor.cpp is doing. It basically take the very first `onTranslateInstructionStart` signal to signalling the module is loaded. It then print the configured module, this `CfgList` should be automatically checked before.

The purpose of define `opLoadConfiguredModule()` and `opLoadModule` is that if custom code is called from QEMU, the callback `RawMonitor::onCustomInstruction` will be called, if the custom code is correct, those function will be called instead of calling the `onLoadModule`.

<a name="Example: onCustomInsruction" />
## Example: onCustomInsruction
**important**
This is how it does, in the file `translate.c`, function `disas_insn` called function `s2e_tcg_emit_custom_instruction(g_s2e, arg)`, the later is defined in `CorePlugin.cpp`. `s2e_tcg_emit_custom_instruction()` call `s2e_tcg_custom_instruction_handler()`, inside which the `onCustomInstruction.emit(g_s2e_state, arg)` is called. 

<a name="ModuleExecutionDetector.h" />
## ModuleExecutionDetector.h

Defined following signals:
```cpp
    /** Signal that is emitted on 
    */
	onModuleTransition;

    /** Signal that is emitted on beginning and end of code generation
        for each translation block belonging to the module. (from the code)
    */
	onModuleTranslateBlockStart;

    /** Signal that is emitted upon end of translation block of the module */
	onModuleTranslateBlockEnd;

    /** This filters module loads passed by OSInterceptor */
	onModuleLoad;
```
__Pay attention to the comment about `onModuleTranslateBlockStart`, it doesn't match the meaning of `onModuleTranslateBlockStart`. When you want to use those signals, you have to track back to the signal emit spot to identify which on is true__

It also define the following private member functions:
```cpp
void onCustomInstruction(S2EExecutionState *state, uint64_t operand);

void onTranslateBlockStart(ExecutionSignal *signal,
        S2EExecutionState *state,
        TranslationBlock *tb,
        uint64_t pc);

void onTranslateBlockEnd(
        ExecutionSignal *signal,
        S2EExecutionState* state,
        TranslationBlock *tb,
        uint64_t endPc,
        bool staticTarget,
        uint64_t targetPc);

void onExecution(S2EExecutionState *state, uint64_t pc);

void exceptionListener(
        S2EExecutionState* state,
        unsigned intNb,
        uint64_t pc
    );

void moduleLoadListener(
        S2EExecutionState* state,
        const ModuleDescriptor &module
    );

void moduleUnloadListener(
        S2EExecutionState* state,
        const ModuleDescriptor &desc);

void processUnloadListener(
        S2EExecutionState* state,
        uint64_t pid);
```
and the following public member functions:
```cpp
    const ModuleDescriptor *getModule(S2EExecutionState *state, uint64_t pc, bool tracked=true);
    const ModuleDescriptor *getCurrentDescriptor(S2EExecutionState* state) const;
    const std::string *getModuleId(const ModuleDescriptor &desc) const;

    void dumpMemory(S2EExecutionState *state,
                    llvm::raw_ostream &os_llvm,
                    uint64_t va, unsigned count);

    const ConfiguredModulesById &getConfiguredModulesById() const {
        return m_ConfiguredModulesId;
    }

    bool isModuleConfigured(const std::string &moduleId) const;
```

There is also a `class ModuleTransitionState` defined in this file. It also declare a signal `onModuleTransition`:
```cpp
    sigc::signal<void,
      S2EExecutionState*,
      const ModuleDescriptor*, //PreviousModule
      const ModuleDescriptor*  //NewModule
    >onModuleTransition;
```
It has the following private member functions:
```cpp
    const ModuleDescriptor *getDescriptor(uint64_t pid, uint64_t pc, bool tracked=true) const;
    bool loadDescriptor(const ModuleDescriptor &desc, bool track);
    void unloadDescriptor(const ModuleDescriptor &desc);
    void unloadDescriptorsWithPid(uint64_t pid);
    bool exists(const ModuleDescriptor *desc, bool tracked) const;
```

<a name="ModuleExecutionDetector.cpp" />
## ModuleExecutionDetector.cpp

> This plugin tracks the modules which are being executed at any given point. Which means it track modules in different states when executing.

> A module is a piece of code defined by a name. Currently the pieces of code are derived from the actual executabel files reported by the OS Monitor.

In the initialize function `void ModuleExecutionDetector::initialize()`, it connect the following signals:
```cpp
    m_Monitor->onModuleLoad.connect(
        sigc::mem_fun(*this, &ModuleExecutionDetector::moduleLoadListener));

    m_Monitor->onModuleUnload.connect(
        sigc::mem_fun(*this, &ModuleExecutionDetector::moduleUnloadListener));

    m_Monitor->onProcessUnload.connect(
        sigc::mem_fun(*this, &ModuleExecutionDetector::processUnloadListener));

    s2e()->getCorePlugin()->onTranslateBlockStart.connect(
        sigc::mem_fun(*this, &ModuleExecutionDetector::onTranslateBlockStart));

    s2e()->getCorePlugin()->onTranslateBlockEnd.connect(
            sigc::mem_fun(*this, &ModuleExecutionDetector::onTranslateBlockEnd));

    s2e()->getCorePlugin()->onException.connect(
        sigc::mem_fun(*this, &ModuleExecutionDetector::exceptionListener));

    s2e()->getCorePlugin()->onCustomInstruction.connect(
        sigc::mem_fun(*this, &ModuleExecutionDetector::onCustomInstruction));
    initializeConfiguration();
```
The member function `void ModuleExecutionDetector::initializeConfiguration()` is does what it said. It read the configure list in the .lua file and add each of those configured module to the set `m_ConfigureModulesName`. It check the uniqueness of the ids and moduleNames before adding.

The `void ModuleExecutionDetector::moduleLoadListener()` is implemented bellow:
```cpp
void ModuleExecutionDetector::moduleLoadListener(
    S2EExecutionState* state,
    const ModuleDescriptor &module)
{
    DECLARE_PLUGINSTATE(ModuleTransitionState, state);

    //If module name matches the configured ones, activate.
    s2e()->getDebugStream() << "ModuleExecutionDetector: " <<
            "Module "  << module.Name << " loaded - " <<
            "Base=" <<  hexval(module.LoadBase) << " Size=" << hexval(module.Size);


    ModuleExecutionCfg cfg;
    cfg.moduleName = module.Name;

    if (m_ConfigureAllModules) {
       /* omit, see the source */
    }

    ConfiguredModulesByName::iterator it = m_ConfiguredModulesName.find(cfg);
    if (it != m_ConfiguredModulesName.end()) {
        if (plgState->exists(&module, true)) {
            s2e()->getDebugStream() << " [ALREADY REGISTERED ID=" << (*it).id << "]" << '\n';
        }else {
            s2e()->getDebugStream() << " [REGISTERING ID=" << (*it).id << "]" << '\n';
            plgState->loadDescriptor(module, true);
            __onModuleLoad.emit(state, module);__
        }
        return;
    }

    s2e()->getDebugStream() << '\n';

    if (m_TrackAllModules) {
	/* omit; see the source*/
    }
}
```
Very important point is that the `onModuleLoad` signal emit here is not from OSMonitor, which most of the   onModuleLoad signal connected. It is a exportable version from `ModuleExecutionDetector` plugins. In fact, annotation plugin has imported `ModuleExecutionDetectior::onModuleLoad` to "activiate all the relevant rules for each module" (From `Annotation.cpp`).
 
Other member functions that are very intresting are:
```cpp
void ModuleExecutionDetector::onTranslateBlockStart(
    ExecutionSignal *signal, 
    /* type of signal emitted on instruction execution, 
       it will be dynamically created and destroyed on demand during translation. */
    S2EExecutionState *state,
    TranslationBlock *tb,
    uint64_t pc)
{
    DECLARE_PLUGINSTATE(ModuleTransitionState, state);

    uint64_t pid = m_Monitor->getPid(state, pc);

    const ModuleDescriptor *currentModule =
            plgState->getDescriptor(pid, pc);

    if (currentModule) {
        //S2E::printf(s2e()->getDebugStream(), "Translating block %#"PRIx64" belonging to %s\n",pc, currentModule->Name.c_str());
        signal->connect(sigc::mem_fun(*this, &ModuleExecutionDetector::onExecution));

        onModuleTranslateBlockStart.emit(signal, state, *currentModule, tb, pc);
    }
}
```
This callback connected to `CorePlugin::onTranslateBlockStart` is connected in the `ModuleExecutionDetector::initialize()` and the signal is emmited in the function `s2e_on_translate_block_start()` in `CorePlugin.cpp`, which will be called by QEMU. The signal `CorePlugin::onTranslateBlockStart` is emitted on beginning and end of code generation for each QEMU translation block(`CorePluing.h`).

So the story is like this: when the QEMU code generation start a block translation, it will emit signal `onTranslateBlockStart`, the `ModuleExecutioDetector::onTranslateBlockStart` callback is called, inside the callback, it retrive the currentModule, if ture, it connect the current state instruction execution signal to member function `ModuleExecutioDetector::onExecution`. Finally it emit `onModuleTranslateBlockStart.emit()`, which is a signal that emitted on beginning and end of code generation for each translation block belonging to the module. The signal `onModuleTranslateBlockStart` is connected in other plugins. _do a grep upon the `Plugins` folder_

In `ModuleExecutionDetector::onTranslateBlockEnd()`, it called `getCurrentDescriptor(state)`, which will return the descriptor of the module that is currently being executed. Be aware that __This works only when tracking of all modules is activated.__ 

It also connect the `ModuleExecutionDetector::onExcution` callback function with the current state instruction execution signal. This signal is very important because we want to monitor syscall and library from now on. More specifically, we can connet this signal to a member function `SyscallMonitor::onBlockExecution()`, in which we enable the syscall interceptions until next `onModuleTranslateStart` emit signal, which basically mean the monitored block is finished execution. The process is start all over. We check whether next block is the block we are insterested, upon recieve the `onTranslateBlockStart` signal, we invode the onExecution syscall, do the same things, which is system call monitor and library call monitor.

<a name="init_env.c" />
## init_env.c

In this guest library implementation, it actually talk to (doing part of their job) RawMonitor and ModuleExecutionDetector Plugins. It call `s2e_rawmon_loadmodule2()` to register modules use a opcode. This is why some of the member function defined with the `op` prefix. And most of them are executed upon the `onCustomInstruction` signal emition, __which is emited every time when custom opcode is detected.__

Also keep an eye on the inline assembly function call `s2e_moduleexec_add_module(base, base, 0)`; It progammatically add a new configuration entry to the ModuleExecutionDetector plugin.

Here is some of other inline function called from this file which is importants.
```
line#
237 s2e_codeselector_select_module("init_env.so");// select code of init_env.so
297 s2e_codeselector_enable_address_space(0);// Forking in the current process's address space
302 s2e_codeselector_enable_address_space(1);// Forking in the user mode of current ps' address space
308 s2e_codeselector_select_module(process_base_name);// select code of open (the testing program)
```

<a name ="CodeSelector.h" />
## CodeSelector.h

<a name ="CodeSelector.cpp" />
## CodeSelector.cpp

In the `void CodeSelector::initialize()`, it read the configured moduleIds, insert it into a set `m_interceptedModules`. It attach following signals:
```cpp
    m_executionDetector->onModuleTransition.connect(
        sigc::mem_fun(*this, &CodeSelector::onModuleTransition));

    s2e()->getCorePlugin()->onCustomInstruction.connect(
        sigc::mem_fun(*this, &CodeSelector::onCustomInstruction));
```

The following member function does what it suppose to do:
```cpp
void CodeSelector::onModuleTransition(
        S2EExecutionState *state,
        const ModuleDescriptor *prevModule,
        const ModuleDescriptor *currentModule
        )
{
    if (!currentModule) {
        state->disableForking();
        return;
    }

    const std::string *id = m_executionDetector->getModuleId(*currentModule);
    if (m_interceptedModules.find(*id) == m_interceptedModules.end()) {
        state->disableForking();
        return;
    }

    state->enableForking();
}
```

It also have onCustomInstruction callback function connected to onCustomInstruction signal. Custom instruction include `opSelectProcess(state)`, `opUnselectProcess(state)`, and `opSelectModule(state)`. The `opSelectProcess(state)` is read CPU register value to decide if it is in user space, if true, it almost do nothing except connect the `onPrivilegeChange`. When the signal is emitted and the callback is called. In the callback, it decide whether there is no pidToTrack, or current pid doesn't belong to `m_pidToTrack`. Both case return the immediately. The third case is to first decide whether we are in a tracking process, if yes(__the value of m_pidToTrack is false, which mean we already tracking it, it clear the bit upon enter the tracking process.__), it test whether it is in user-mode, if yes(tell by hard-coded CPL level), enable forking by calling `state->enableForking()`, otherwise `state->disableForking()`.
```cpp
void CodeSelector::opSelectProcess(S2EExecutionState *state)
{
    bool ok = true;
    target_ulong isUserSpace;
    ok &= state->readCpuRegisterConcrete(CPU_OFFSET(IS_USERSPACE), &isUserSpace,
                                                    sizeof isUserSpace);


    if (isUserSpace) {
        //Track the current process, but user-space only
        m_pidsToTrack[state->getPid()] = false;

        if (!m_privilegeTracking.connected()) {
            m_privilegeTracking = s2e()->getCorePlugin()->onPrivilegeChange.connect(
                    sigc::mem_fun(*this, &CodeSelector::onPrivilegeChange));
        }
    } else {
        m_pidsToTrack[state->getPid()] = true;

		/* might be a bug here ???!!!
        if (!m_privilegeTracking.connected()) {
            m_privilegeTracking = s2e()->getCorePlugin()->onPageDirectoryChange.connect(
                    sigc::mem_fun(*this, &CodeSelector::onPageDirectoryChange));
        } */
		//corrected code
        if (!m_addressSpaceTracking.connected()) {
            m_addressSpaceTracking = s2e()->getCorePlugin()->onPageDirectoryChange.connect(
                    sigc::mem_fun(*this, &CodeSelector::onPageDirectoryChange));
        }

    }
}
```
If the reading CPU register value returned that it isn't in user space, we go else, which is set it to true(mean to be tracke, clear the bit upon entering tracking). It then connect a signal `onPageDirectoryChange` from CorePlugin, the callback will be called upon process switch. In the callback, it decide, the new process is tracked or not, based on the value of the `m_pidsToTrack`, it either enable or disable the forking for the current state.

<a name="ExecutionTracer.h" />
## ExecutionTracer.h

Simple file, has the following member functions:

```cpp
public:
	getCompressedId();
	onTimer();
	createNewTraceFile(bool append);
private:
	writeData();
	flush();
	onFork();
	onProcessFork();
```

<a name="ExecutionTracer.cpp" />
## ExecutionTracer.cpp

> The ExecutionTracer plugin is the main tracing plugin. This plugin saves a binary trace file in the
> `ExecutionTracer.dat` file. This file is composed of generic trace items. Each item can have an arbitrary
> format, determined by the various client tracing plugins. The client plugins call the ExecutionTracer's 
> API to write trace items.
> 
> By default, ExecutionTracer records the program counters where fork occurs. This allows offline analysis 
> tools to rebuild the execution tree and provide per-path analyses.


<a name="ModuleTracer.h" />
## ModuleTracer.h

Defined a `class ModuleTracer` which is inherited from `class EventTracer`, and `class ModuleTracerState`, 

<a name="ModuleDescriptor.h" />
## ModuleDescriptor.h

It define following maps:
```cpp
//Maps the name of the exported function to its actual address
typedef std::map<std::string,uint64_t> Exports;
  
//Maps the name of the function to its actual address
//XXX: Rename the type ImportedFunctions to ImportedSymbol.
typedef std::map<std::string, uint64_t> ImportedFunctions;
  
//Maps the library name to the set of functions it exports
typedef std::map<std::string, ImportedFunctions > Imports;
```
It also defines some section of Memory
```cpp
struct SectionDescriptor
{
    enum SectionType {
        READ=1, WRITE=2, READWRITE=3,
        EXECUTE=4
    };

    uint64_t loadBase;
    uint64_t size;
    SectionType type;
    std::string name;

    void setRead(bool b) {/* omit */}
    void setWrite(bool b) {/* omit */}
    void setExecute(bool b) {/* omit */}

    bool isReadable() const { return type & READ; }
    bool isWritable() const { return type & WRITE; }
    bool isExecutable() const { return type & EXECUTE; }
};
```
It also declare another structure:
```cpp
/**
 *  Characterizes whatever module can be loaded in the memory.
 *  This can be a user-mode library, or a kernel-mode driver.
 */
struct ModuleDescriptor
{
  uint64_t  Pid;
  
  //The name of the module (eg. MYAPP.EXE or DRIVER.SYS)
  std::string Name;
  
  //Where the the preferred load address of the module.
  //This is defined by the linker and put into the header of the image.
  uint64_t NativeBase;
  
  //Where the image of the module was actually loaded by the OS.
  uint64_t LoadBase;
  
  //The size of the image of the module
  uint64_t Size;

  //The entry point of the module
  uint64_t EntryPoint;

  //A list of sections
  ModuleSections Sections;

  ModuleDescriptor() {
    Pid = 0;
    NativeBase = 0;
    LoadBase = 0;
    Size = 0;
    EntryPoint = 0;
  }

  bool Contains(uint64_t RunTimeAddress) const {
    uint64_t RVA = RunTimeAddress - LoadBase;
    return RVA < Size;
  }

  uint64_t ToRelative(uint64_t RunTimeAddress) const {
    uint64_t RVA = RunTimeAddress - LoadBase;
    return RVA;
  }

  uint64_t ToNativeBase(uint64_t RunTimeAddress) const {
    return RunTimeAddress - LoadBase + NativeBase;
  }

  uint64_t ToRuntime(uint64_t NativeAddress) const {
    return NativeAddress - NativeBase + LoadBase;
  }

  bool EqualInsensitive(const char *Name) const{
	return strcasecmp(this->Name.c_str(), Name) == 0;
  }

  struct ModuleByLoadBase {
    bool operator()(const struct ModuleDescriptor& s1, 
      const struct ModuleDescriptor& s2) const {
        if (s1.Pid == s2.Pid) {
            return s1.LoadBase + s1.Size <= s2.LoadBase;
        }
        return s1.Pid < s2.Pid;
    }

    bool operator()(const struct ModuleDescriptor* s1,
      const struct ModuleDescriptor* s2) const {
        if (s1->Pid == s2->Pid) {
            return s1->LoadBase + s1->Size <= s2->LoadBase;
        }
        return s1->Pid < s2->Pid;
    }
  };

  struct ModuleByName {
    bool operator()(const struct ModuleDescriptor& s1,
      const struct ModuleDescriptor& s2) const {
        return s1.Name < s2.Name;
    }

    bool operator()(const struct ModuleDescriptor* s1,
      const struct ModuleDescriptor* s2) const {
        return s1->Name < s2->Name;
    }
  };

  void Print(llvm::raw_ostream &os) const {
    os << "Name=" << Name  <<
      " NativeBase=" << hexval(NativeBase) << " LoadBase=" << hexval(LoadBase) <<
      " Size=" << hexval(Size) <<
      " EntryPoint=" << hexval(EntryPoint) << '\n';
  }

  typedef std::set<struct ModuleDescriptor, ModuleByLoadBase> MDSet;
};
```

<a name=".h" />
## .h

<a name=".cpp" />
## .cpp



<a name="S2E.h"/>
## S2E.h

About 248 line of code, declare two data structure `struct S2EShared` for sych among multiple instances of S2E, and `class S2E` for initialize . The `struct S2EShared` is:

```cpp
//Structure used for synchronization among multiple instances of S2E
struct S2EShared {
    unsigned currentProcessCount;
    unsigned lastFileId;
    //We must have unique state ids across all processes
    //otherwise offline tools will be extremely confused when
    //aggregating different execution trace files.
    unsigned lastStateId;

    //Array of currently running instances.
    //Each entry either contains -1 (no instance running) or
    //the instance index.
    unsigned processIds[S2E_MAX_PROCESSES];
    unsigned processPids[S2E_MAX_PROCESSES];
    S2EShared() {
        for (unsigned i=0; i<S2E_MAX_PROCESSES; ++i)    {
            processIds[i] = (unsigned)-1;
            processPids[i] = (unsigned)-1;
        }
    }
};
```

The `S2E` maintain some variables and data structures for QUME. At this moment, I don't get into QEMU and LLVM. `S2E` member functions include: 
- `getConfig()`, 
- `getPlugin()`, 
- `getCorePlugin()`, 
- `getOutputDirectory()`, 
- `getOutputFilename()`, 
- `openOutputFile()`, 
- `getInfoStream()`, 
- `getDebugStream()`, 
- `getMessagesStream()`, 
- `getWarningStream()`, 
- `getExecutor()`, 
- `refreshPlugins()`, 
- `writeBitCodeToFile()`, 
- `fork()`, 
- `isForking()`, 
- `fetchAndIncrementStateID()`, 
- `fetchNextStable()`, 
- `getMaxProcesses()`, 
- `getCurrentProcessId()`, 
- `getCurrentProcessIndex()`, 
- `getProcessIndexForId()`, 
- `getCurrentProcessCount()`, 
- `checkDeadProcesses()`, 
- `getStartTime()`. 

Most of those member functions are for QEMU to call. Generally, it is the S2E API for QEMU. _The Plugins are talk to QEMU through S2E class._ 

<a name="S2E.cpp"/>
## S2E.cpp

Implementation of all the member functions that declared in the `S2E.h` file. We need to take a look at the `fork()` implementation. Nothing special until line 680, following is an exert from line 680 to line 709:

```cpp
        ...
        m_currentProcessIndex = newProcessIndex;
        //We are the child process, setup the log files again
        initOutputDirectory(m_outputDirectoryBase, 0, true);
        //Also recreate new statistics files
        m_s2eExecutor->initializeStatistics();
        //And the solver output
        m_s2eExecutor->initializeSolver();

        m_forking = true;

        qemu_init_cpu_loop(); /**  */
        if (main_loop_init()) {
            fprintf(stderr, "qemu_init_main_loop failed\n");
            exit(1);
        }

        if (init_timer_alarm(0)<0) {
            getDebugStream() << "Could not initialize timers" << '\n';
            exit(-1);
        }

        qemu_init_vcpu(env);
        cpu_synchronize_all_post_init();
        os_setup_signal_handling();
        vm_start();
        os_setup_post();
        resume_all_vcpus();
        vm_stop(RUN_STATE_SAVE_VM);

        m_forking = false;
        ...
```

The process run as a children process, so have todo some initialization in the begining. Then there are more QEMU functions called.

On the bottom of the file, there are a `extern "C" {}` block, which define some functions called from QEMU. Basically, those are wrapper functions to call the member functions defined in the `class S2E` class. For example, the following function definition:

```cpp
 S2E* s2e_initialize(int argc, char** argv,
            TCGLLVMContext* tcgLLVMContext,
            const char* s2e_config_file,  const char* s2e_output_dir,
            int verbose, unsigned s2e_max_processes)
{
    return new S2E(argc, argv, tcgLLVMContext,
                   s2e_config_file ? s2e_config_file : "",
                   s2e_output_dir  ? s2e_output_dir  : "",
                   verbose, s2e_max_processes);
}
```

It bascially return an initialized object to the caller.

On s2e_close, it first print a stack trace by calling the function ` print_stacktrace()`, which is defined at the begining of this file. Read the source of this function if you have time. I might be very valuable in implement this technique.

<a name="reference"/>
## References

[1. tsinghua.edu.cn](http://os.cs.tsinghua.edu.cn/oscourse/OS2012/projects/U03)
[2. Ucore_tool_s2e](https://github.com/chyyuu/ucore_tool_s2e)
[alienDetector]: https://developer.gnome.org/libsigc++-tutorial/2.2/ch02.html
