S2E source code
===
####Table of contenst:

- [How to Write an S2E plugin?](#HowtoS2EPlugin)
- [S2E.h](#S2E.h)
- [S2E.cpp](#S2E.cpp)
- [References](#reference)

<a name="HowtoS2EPlugin" />
## How to Write an S2E plugin

- Plugin - count how many times a specific instruction has been executed.
- configuration file - specify which instruction to watch.
- communication - with other plugins and expose reusable functionality.

The example gives the template for writing a plugin. Several things to understand:
1. Reading Configuration parameters
2. Register callback with signals

For 1. there is a code snippets that read the value from the configuration file.
```cpp
//...

void InstructionTracker::initialize()
{
    m_address = (uint64_t) s2e()->getConfig()->getInt(getConfigKey() + ".addressToTrack");
}
```

Here noticed the ".addressToTrack" string is the name of the configured value in the config file.

For 2. You need to understand how signal works and how the callback parameters is passed. 

__TODO: Try several tutorial examples about signal and callback function. understand the gist of the signal and callback.__

Let's see a very simple exaple of signal and callback from the [tutorial of sigc++][alienDetector]

```cpp
#include <iostream>
#include <string>
#include <sigc++/sigc++.h>
using namespace std;

//define the object that emit the signal
class AlienDetector
{
public:
	AlienDetector();

	void run();

	sigc::signal<void> signal_detected;
	sigc::signal<void, std::string> signalx_detected;
	sigc::signal<void, std::string, std::string> signaly_detected;
};

//Constructor
AlienDetector::AlienDetector(){}

//Member function that going to be emit signal
void AlienDetector::run()
{
	sleep(3);
	signal_detected.emit();
	signalx_detected.emit("grage");
	signaly_detected.emit("Polar Bear", "basement");
}

/****************************************************************************************************/
//Sophisticated alien alerter class
class AlienAlerter: public sigc::trackable
{
public:
	AlienAlerter(char const* servername);
	void alert();
	void alert2(string name, string where);
private:

};

//Constructor
AlienAlerter::AlienAlerter(char const*){}

//Member function as callback function. no parameters. 
void AlienAlerter::alert()
{
	cout << "sigc::mem_fun# AlienAlerter::alert() \n" 
	     << "There are aliens in the car park!" << endl;
}

//Member function as callback function. with two parameters. 
void AlienAlerter::alert2(string name, string where)
{
	cout << "sigc::mem_fun# AlienAlerter::alert(string, string) \n" 
	     << "There are " << name << " in the " << where << "!" << endl;
}

/****************************************************************************************************/
//Stand alone alert function that take one parameter.
void alerter(string where)
{
	cout << "sigc::ptr_fun# alerter() \n" << "There are aliens in the " 
	     << where << "!" << endl;
}

//Client function that connect to the signal and trigger the callback function
//call by run a demo member function from the object. 
int main()
{
	AlienDetector mydetector;
	AlienAlerter myalerter("localhost");
	
	//Connect to the signal that just invoke a stand alone function as a
	//callback, and there are not parameters. 
	mydetector.signalx_detected.connect(sigc::ptr_fun(alerter));

	//Connect to the signal that passing a string as a parameter. The
	//parameter is passed by the operator() or emit(). In other words, the
	//parameter passed to the emit() or operator() shoud mach the define of the
	//signal. 
	mydetector.signal_detected.connect(sigc::mem_fun(myalerter, &AlienAlerter::alert));

	//Connect to the signal that passing two string as parameters.
	mydetector.signaly_detected.connect(sigc::mem_fun(myalerter, &AlienAlerter::alert2));

	mydetector.run();
	
	return 0;
}
```

There are several points need to be remembered to understand signal and slot.

1. Define signals inside an object that want to emit signal when certain conditions are met.
- Connect a signal to slot(callbacks) in the initialize process.
- Client code that trigger the emit of the particular signal.
- Callback parameters could be declared in the signal declaration.
- The parameter passed to the callback by the emit() member function or overloaded operator().

####PluginState

The tutorial describe how to keep per-state plugin information in class `PluginState{}`. That is: the plugin works for each path independently. Two member function are needed. One for creating a new instance of the specific `PluginState` when s2e start symbolic execution. The other is a clone method that s2e used to fork plugin state when forking execution states during the execution. S2E automatically fork user code state when a new branch need to execute for the application, Plugin State have to be forked manually in the meantime by us.

   

<a name="S2E.h"/>
## S2E.h

About 248 line of code, declare two data structure `struct S2EShared` for sych among multiple instances of S2E, and `class S2E` for initialize . The `struct S2EShared` is:

```cpp
//Structure used for synchronization among multiple instances of S2E
struct S2EShared {
    unsigned currentProcessCount;
    unsigned lastFileId;
    //We must have unique state ids across all processes
    //otherwise offline tools will be extremely confused when
    //aggregating different execution trace files.
    unsigned lastStateId;

    //Array of currently running instances.
    //Each entry either contains -1 (no instance running) or
    //the instance index.
    unsigned processIds[S2E_MAX_PROCESSES];
    unsigned processPids[S2E_MAX_PROCESSES];
    S2EShared() {
        for (unsigned i=0; i<S2E_MAX_PROCESSES; ++i)    {
            processIds[i] = (unsigned)-1;
            processPids[i] = (unsigned)-1;
        }
    }
};
```

The `S2E` maintain some variables and data structures for QUME. At this moment, I don't get into QEMU and LLVM. `S2E` member functions include: 
- `getConfig()`, 
- `getPlugin()`, 
- `getCorePlugin()`, 
- `getOutputDirectory()`, 
- `getOutputFilename()`, 
- `openOutputFile()`, 
- `getInfoStream()`, 
- `getDebugStream()`, 
- `getMessagesStream()`, 
- `getWarningStream()`, 
- `getExecutor()`, 
- `refreshPlugins()`, 
- `writeBitCodeToFile()`, 
- `fork()`, 
- `isForking()`, 
- `fetchAndIncrementStateID()`, 
- `fetchNextStable()`, 
- `getMaxProcesses()`, 
- `getCurrentProcessId()`, 
- `getCurrentProcessIndex()`, 
- `getProcessIndexForId()`, 
- `getCurrentProcessCount()`, 
- `checkDeadProcesses()`, 
- `getStartTime()`. 

Most of those member functions are for QEMU to call. Generally, it is the S2E API for QEMU. _The Plugins are talk to QEMU through S2E class._ 

<a name="S2E.cpp"/>
## S2E.cpp

Implementation of all the member functions that declared in the `S2E.h` file. We need to take a look at the `fork()` implementation. Nothing special until line 680, following is an exert from line 680 to line 709:

```cpp
        ...
        m_currentProcessIndex = newProcessIndex;
        //We are the child process, setup the log files again
        initOutputDirectory(m_outputDirectoryBase, 0, true);
        //Also recreate new statistics files
        m_s2eExecutor->initializeStatistics();
        //And the solver output
        m_s2eExecutor->initializeSolver();

        m_forking = true;

        qemu_init_cpu_loop(); /**  */
        if (main_loop_init()) {
            fprintf(stderr, "qemu_init_main_loop failed\n");
            exit(1);
        }

        if (init_timer_alarm(0)<0) {
            getDebugStream() << "Could not initialize timers" << '\n';
            exit(-1);
        }

        qemu_init_vcpu(env);
        cpu_synchronize_all_post_init();
        os_setup_signal_handling();
        vm_start();
        os_setup_post();
        resume_all_vcpus();
        vm_stop(RUN_STATE_SAVE_VM);

        m_forking = false;
        ...
```

The process run as a children process, so have todo some initialization in the begining. Then there are more QEMU functions called.

On the bottom of the file, there are a `extern "C" {}` block, which define some functions called from QEMU. Basically, those are wrapper functions to call the member functions defined in the `class S2E` class. For example, the following function definition:

```cpp
 S2E* s2e_initialize(int argc, char** argv,
            TCGLLVMContext* tcgLLVMContext,
            const char* s2e_config_file,  const char* s2e_output_dir,
            int verbose, unsigned s2e_max_processes)
{
    return new S2E(argc, argv, tcgLLVMContext,
                   s2e_config_file ? s2e_config_file : "",
                   s2e_output_dir  ? s2e_output_dir  : "",
                   verbose, s2e_max_processes);
}
```

It bascially return an initialized object to the caller.

On s2e_close, it first print a stack trace by calling the function ` print_stacktrace()`, which is defined at the begining of this file. Read the source of this function if you have time. I might be very valuable in implement this technique.

<a name="reference"/>
## References

[1. tsinghua.edu.cn](http://os.cs.tsinghua.edu.cn/oscourse/OS2012/projects/U03)
[2. Ucore_tool_s2e](https://github.com/chyyuu/ucore_tool_s2e)
[alienDetector]: https://developer.gnome.org/libsigc++-tutorial/2.2/ch02.html
