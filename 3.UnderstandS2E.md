S2E source code
===
####Table of contenst:

- [How to Write an S2E plugin?](#HowtoS2EPlugin)
   - [AlienDetector Example](#AlienDetector) _simplest runable example to understand signal and slot._
   - [InstructionTracker.h](#InstructionTracker.h) _s2e tutorial "How to Write an S2E Plugin?" complete code._
- [CorePlugin.cpp](#CorePlugin.cpp) _definition of functions called from QEMU to trigger emit_
- [CorePlugin.h](#CorePlugin.h) _declaration of signals, i.e `onModuleExecution`_
- [BaseInstructions.cpp](#BaseInstructions.cpp) _s2e basic functionalities, `makeSybolic()` etc._
- [BaseInstructions.h](#BaseInstructions.h) 
- [ExecutionTracer.cpp](#ExecutionTracer.cpp)_create ExecutionTracer.dat file, each write is encapsulated in an ExecutionTraceItem before written to disk._
- [ExecutionTracer.h](#ExecutionTracer.h)
- [ModuleExecutionDetector.cpp](#ModuleExecutionDetector.cpp) _function to read configured module info, define `moduleLoadListener`, __`onTranslationBlockStart`__ member functions. `class ModuleTransitionState`._
- [ModuleExecutionDetector.h](#ModuleExecutionDetector.h)
- [RawMonitor.cpp](#RawMonitor.cpp) _emit signal after load module succesfully in `loadModule` and `opLoadModule`._
- [RawMonitor.h](#RawMonitor.h) _class inherited from `OSMonitor`, include `struct Cfg` _
- [OSMonitor.h](#OSMonitor.h) _define signals such as `onModuleLoad`, `onProcessUnload`, and member functions such as `getImports()`, `getCurrentStack()`._
- [ModuleTracer.cpp](#ModuleTracer.cpp) _also define the memeber function `moduleLoadListener`, find out the difference between it and `ModuleExecutionDetector.cpp`_
- [ModuleTracer.h](#ModuleTracer.h) _`class ModuleTracerState`, and `addModule`, `getCurrentModule` meber functions._
- [ModuleDescriptor.h](#ModuleDescriptor.h) only included in `RawMonitor.h`, `OSMonitor.h`, `MemoryChecker.cpp`, and `ModuleExecutionDetector.h`
- [.cpp](#.cpp)
- [.h](#.h)
- [S2E.h](#S2E.h)
- [S2E.cpp](#S2E.cpp)
- [References](#reference)

<a name="HowtoS2EPlugin" />
## How to Write an S2E plugin

- Plugin - count how many times a specific instruction has been executed.
- configuration file - specify which instruction to watch.
- communication - with other plugins and expose reusable functionality.

The example gives the template for writing a plugin. Several things to understand:

1. Reading configuration parameters
2. Register callback with signals

For 1. there is a code snippets that read the value from the configuration file.
```cpp
//...

void InstructionTracker::initialize()
{
    m_address = (uint64_t) s2e()->getConfig()->getInt(getConfigKey() + ".addressToTrack");
}
```

Here noticed the ".addressToTrack" string is the name of the configured value in the config file.

For 2. You need to understand how signal works and how the callback parameters is passed. Let's see a very simple exaple of signal and callback from the [tutorial of sigc++][alienDetector]

<a name="AlienDetector" />
### AlientDetector Example
```cpp
#include <iostream>
#include <string>
#include <sigc++/sigc++.h>
using namespace std;

//define the object that emit the signal
class AlienDetector
{
public:
	AlienDetector();

	void run();

	sigc::signal<void> signal_detected;
	sigc::signal<void, std::string> signalx_detected;
	sigc::signal<void, std::string, std::string> signaly_detected;
};

//Constructor
AlienDetector::AlienDetector(){}

//Member function that going to be emit signal
void AlienDetector::run()
{
	sleep(3);
	signal_detected.emit();
	signalx_detected.emit("grage");
	signaly_detected.emit("Polar Bear", "basement");
}

/****************************************************************************************************/
//Sophisticated alien alerter class
class AlienAlerter: public sigc::trackable
{
public:
	AlienAlerter(char const* servername);
	void alert();
	void alert2(string name, string where);
private:

};

//Constructor
AlienAlerter::AlienAlerter(char const*){}

//Member function as callback function. no parameters. 
void AlienAlerter::alert()
{
	cout << "sigc::mem_fun# AlienAlerter::alert() \n" 
	     << "There are aliens in the car park!" << endl;
}

//Member function as callback function. with two parameters. 
void AlienAlerter::alert2(string name, string where)
{
	cout << "sigc::mem_fun# AlienAlerter::alert(string, string) \n" 
	     << "There are " << name << " in the " << where << "!" << endl;
}

/****************************************************************************************************/
//Stand alone alert function that take one parameter.
void alerter(string where)
{
	cout << "sigc::ptr_fun# alerter() \n" << "There are aliens in the " 
	     << where << "!" << endl;
}

//Client function that connect to the signal and trigger the callback function
//call by run a demo member function from the object. 
int main()
{
	AlienDetector mydetector;
	AlienAlerter myalerter("localhost");
	
	//Connect to the signal that just invoke a stand alone function as a
	//callback, and there are not parameters. 
	mydetector.signalx_detected.connect(sigc::ptr_fun(alerter));

	//Connect to the signal that passing a string as a parameter. The
	//parameter is passed by the operator() or emit(). In other words, the
	//parameter passed to the emit() or operator() shoud mach the define of the
	//signal. 
	mydetector.signal_detected.connect(sigc::mem_fun(myalerter, &AlienAlerter::alert));

	//Connect to the signal that passing two string as parameters.
	mydetector.signaly_detected.connect(sigc::mem_fun(myalerter, &AlienAlerter::alert2));

	mydetector.run();
	
	return 0;
}
```
Above code can be compiled using the following command line:

```bash
g++ example1.cc -o example1 `pkg-config --cflags --libs sigc++2.0`
```

There are several points need to be remembered to understand signal and slot.

1. Define signals inside an object that want to emit signal when certain conditions are met.
- Connect a signal to slot(callbacks) in the initialize process.
- Client code that trigger the emit of the particular signal.
- Callback parameters could be declared in the signal declaration.
- The parameter passed to the callback by the emit() member function or overloaded operator().

<a name="InstructionTracker.h" />
## InstructionTracker.h

Let's coming back to S2E's plugin implementation. From the Plugin tutorial, I completed the following code: for `InstructionTracker.h` and `InstructionTracker.cpp`.

The header of InstructionTracker Plugin:
```cpp
#ifndef S2E_PLUGINS_INSTRTRACKER_H
#define S2E_PLUGINS_INSTRTRACKER_H

#include <s2e/Plugin.h>
#include <s2e/Plugins/CorePlugin.h>
#include <s2e/S2EExecutionState.h>

namespace s2e {
namespace plugins {
	
class InstructionTracker: public Plugin
{
	S2E_PLUGIN
	uint64_t m_address;
public:
	InstructionTracker(S2E *s2e): Plugin(s2e) {	}
	sigc::signal<void, S2EExecutionState *, uint64_t> onPeriodicEvent;
	
	void initialize();
	void onInstructionExecution(S2EExecutionState *state, uint64_t pc);
	void onTranslateInstruction(ExecutionSignal *signal, S2EExecutionState *state,
								TranslationBlock *tb, uint64_t pc);
};

}	//namespace plugins
}	//namespace s2e

//Plugin State for per state plugin information.
class InstructionTrackerState: public PluginState
{
    int m_count;

public:
    InstructionTrackerState() {
        m_count = 0;
    }

    ~InstructionTrackerState() {}

    static PluginState *factory(Plugin*, S2EExecutionState*) {
        return new InstructionTrackerState();
    }

    InstructionTrackerState *clone() const {
        return new InstructionTrackerState(*this);
    }

    void increment() { ++m_count; }
    int get() { return m_count; }

};
#endif
```

The Implementation of the InstructionTracker Plugin(InstructionTracker.cpp):
```cpp
#include <s2e/S2E.h>
#include "InstructionTracker.h"

namespace s2e {
namespace plugins {

//Define a plugin whose class is InstructionTracker and called "InstructionTracker".
//The plugin does not have any dependency.
S2E_DEFINE_PLUGIN(InstructionTracker, "Tutorial - Tracking instructions", "InstructionTracker",);

void InstructionTracker::initialize()
{
    m_address = (uint64_t) s2e()->getConfig()->getInt(getConfigKey() + ".addressToTrack");

	//This indicates that our plugin is interested in monitoring instruction translation.
    //For this, the plugin registers a callback with the onTranslateInstruction signal.
    s2e()->getCorePlugin()->onTranslateInstructionStart.connect(
        sigc::mem_fun(*this, &InstructionTracker::onTranslateInstruction));
}

void InstructionTracker::onTranslateInstruction(ExecutionSignal *signal,
												S2EExecutionState *state,
												TranslationBlock *tb,
												uint64_t pc);
{
    if(m_address == pc) {
        //When we find an interesting address, ask S2E to invoke our
        //callback when the address is actually executed.
        signal->connect(sigc::mem_fun(*this, &InstructionTracker::onInstructionExecution));
    }
}

//This callback is called only when the instruction at our address is executed.
//The callback incurs zero overhead for all other instructions.
void InstructionTracker::onInstructionExecution(S2EExecutionState *state, uint64_t pc)
{
    DECLARE_PLUGINSTATE(InstructionTrackerState, state);
    //This declaration will return the plgState object of type InstructionTrackerState. 

    s2e()->getDebugStream() << "Executing instruction at " << hexval(pc) << '\n';
    //The plugins can arbitrarily modify/observe the current execution state via
    //the execution state pointer.
    //Plugins can also call the s2e() method to use the S2E API.
    plgState->increment();

    //Fire the event
    if((plgState->get() % 10) == 0) {
	onPeriodicEvent.emit(state, pc);
    }
}

} // namespace plugins
} // namespace s2e
```
There need a client to run this plugin and trigger the emit of signal. We can see the s2e as the client. It is the `main` function.

####PluginState

The tutorial describe how to keep per-state plugin information in class `PluginState{}`. That is: the plugin works for each path independently. Two member function are needed. One for creating a new instance of the specific `PluginState` when s2e start symbolic execution. The other is a clone method that s2e used to fork plugin state when forking execution states during the execution. S2E automatically fork user code state when a new branch need to execute for the application, Plugin State have to be forked manually in the meantime by us.

<a name="CorePlugin.cpp" />
## CorePlugin.cpp

Define various function called by QEMU events to emit signals. For example:

```cpp
void s2e_tcg_execution_handler(void* signal, uint64_t pc)
{
    try {
        ExecutionSignal *s = (ExecutionSignal*)signal;
        if (g_s2e_enable_signals) {
            s->emit(g_s2e_state, pc);
        }
    } catch(s2e::CpuExitException&) {
        s2e_longjmp(env->jmp_env, 1);
    }
}
```

<a name="CorePlugin.h" />
## CorePlugin.h

Declared all the signals that available to be connected by plugins. For example:

```cpp
    /**
     *  Triggered *after* each instruction is translated to notify
     *  plugins of which registers are used by the instruction.
     *  Each bit of the mask corresponds to one of the registers of
     *  the architecture (e.g., R_EAX, R_ECX, etc).
     */
    sigc::signal<void,
                 ExecutionSignal*,
                 S2EExecutionState* /* current state */,
                 TranslationBlock*,
                 uint64_t /* program counter of the instruction */,
                 uint64_t /* registers read by the instruction */,
                 uint64_t /* registers written by the instruction */,
                 bool /* instruction accesses memory */>
          onTranslateRegisterAccessEnd;
```

<a name="BaseInstructions.cpp" />
## BaseInstructions.cpp

This file implement the following functions declared in header file. They are the majority of S2E functionality implementations, such as `makeSymbolic`, `killState`, etc.

```cpp
    void handleBuiltInOps(S2EExecutionState* state, uint64_t opcode);
    void onCustomInstruction(S2EExecutionState* state, uint64_t opcode);
    void invokePlugin(S2EExecutionState *state);
    void makeSymbolic(S2EExecutionState *state, bool makeConcolic);
    void isSymbolic(S2EExecutionState *state);
    void killState(S2EExecutionState *state);
    void printExpression(S2EExecutionState *state);
    void printMessage(S2EExecutionState *state, bool isWarning);
    void printMemory(S2EExecutionState *state);
    void concretize(S2EExecutionState *state, bool addConstraint);
    void sleep(S2EExecutionState *state);
    void assume(S2EExecutionState *state);
```

There are another object defined in this `BaseInstruction.cpp`, which is `class BaseInstructionPluginInvokeInterface`.

<a name="BaseInstructions.h" />
## BaseInstructions.h

<a name="ExecutionTracer.cpp" />
## ExecutionTracer.cpp

> The ExecutionTracer plugin is the main tracing plugin. This plugin saves a binary trace file in the
> `ExecutionTracer.dat` file. This file is composed of generic trace items. Each item can have an arbitrary
> format, determined by the various client tracing plugins. The client plugins call the ExecutionTracer's 
> API to write trace items.
> 
> By default, ExecutionTracer records the program counters where fork occurs. This allows offline analysis 
> tools to rebuild the execution tree and provide per-path analyses.

<a name="ExecutionTracer.h" />
## ExecutionTracer.h

Simple file, has the following member functions:

```cpp
public:
	getCompressedId();
	onTimer();
	createNewTraceFile(bool append);
private:
	writeData();
	flush();
	onFork();
	onProcessFork();
```

<a name="ModuleExecutionDetector.cpp" />
## ModuleExecutionDetector.cpp

> A module is a piece of code defined by a name. Currently the pieces of code are derived from the actual 
> executabel files reported by the OS Monitor.

Implement the member functions of `class ModuleExecutionDetector` and `class ModuleTransitionState`. the 

In `ModuleExecutionDetector::onTranslateBlockEnd()`, it connect the `ModuleExecutionDetector::onExcution	` callback function, As the code comment in line 438 said, this is in case of dynamic targets, conservatively instrument code. 

__pay attention to the `onModuleTranslateBlockStart.emit()` and `onModuleTranslateBlockEnd.emit()` function in the implementation, this hasn't been connected in the ExecutionModuleDetector plugin, it is connected on `TranslationBlockTracer.cpp` and `Annotation.cpp`.__

<a name="ModuleExecutionDetector.h" />
## ModuleExecutionDetector.h

Defined following signals:
```cpp
    sigc::signal<
        void, S2EExecutionState *,
        const ModuleDescriptor *,
        const ModuleDescriptor *> 
     onModuleTransition;

    /** Signal that is emitted on beginning and end of code generation
        for each translation block belonging to the module.
    */
    sigc::signal<void, ExecutionSignal*,
            S2EExecutionState*,
            const ModuleDescriptor &,
            TranslationBlock*,
            uint64_t /* block PC */>
         onModuleTranslateBlockStart;

    /** Signal that is emitted upon end of translation block of the module */
    sigc::signal<void, ExecutionSignal*,
            S2EExecutionState*,
            const ModuleDescriptor &,
            TranslationBlock*,
            uint64_t /* ending instruction pc */,
            bool /* static target is valid */,
            uint64_t /* static target pc */>
	onModuleTranslateBlockEnd;

    /** This filters module loads passed by OSInterceptor */
    sigc::signal<void,
       S2EExecutionState*,
       const ModuleDescriptor &
    >onModuleLoad;
```

There is also a `class ModuleTransitionState` defined in this file, the member function of it is to manipulate the info of the loaded module ID. such as `getDescriptor()`, `unloadDescriptor()`, and so on.

<a name="RawMonitor.cpp" />
## RawMonitor.cpp

Implement the member functions including `loadModule()` and `opLoadModule()`. In fact `loadModule()` is called from anothe member function `RawMonitor::onTranslateInstructionStart()`. the reason of doing this is because it automatically detect the module has been loaded by the onTranslateInstructionStart events. 
```cpp
void RawMonitor::loadModule(S2EExecutionState *state, const Cfg &c, bool skipIfDelay)
{
    ModuleDescriptor md;
    if (c.delayLoad && skipIfDelay) {
        return;
    }
    md.Name = c.name;
    md.NativeBase = c.nativebase;
    md.LoadBase = c.start;
    md.Size = c.size;
    md.Pid = c.kernelMode ? 0 : state->getPid();
    md.EntryPoint = c.entrypoint;

    s2e()->getDebugStream() << "RawMonitor loaded " << c.name << " " <<
            hexval(c.start) << ' ' << hexval(c.size) << '\n';
    onModuleLoad.emit(state, md);
}

void RawMonitor::onTranslateInstructionStart(ExecutionSignal *signal,
                                                   S2EExecutionState *state,
                                                   TranslationBlock *tb,
                                                   uint64_t pc)
{
    CfgList::const_iterator it;

    for (it = m_cfg.begin(); it != m_cfg.end(); ++it) {
        const Cfg &c = *it;
        loadModule(state, c, true);
    }

    m_onTranslateInstruction.disconnect();
}
```
__TODOs: Figure out the purpose of define `opLoadConfiguredModule()` and `opLoadModule`. When the opcode involked?__

<a name="RawMonitor.h" />
## RawMonitor.h

Didn't define new signals, only inherited from [`OSMonitor.h`](#OSMonitor.h).

<a name="OSMonitor.h" />
## OSMonitor.h
> Base class for default OS actions. It provides an interface for loading/unloading modules > and processes.
> Note: several events use ModuleDescriptor as a parameter. The passed reference is valid 
> only during the call. Do not store pointers to such objects, but make a copy instead.

It defined The following Signals:
```cpp
public:
   sigc::signal<void, S2EExecutionState*, const ModuleDescriptor &> onModuleLoad;
   sigc::signal<void, S2EExecutionState*, const ModuleDescriptor &> onModuleUnload; //used in WindowsMonitor Plugin
   sigc::signal<void, S2EExecutionState*, const ThreadDescriptor&> onThreadCreate;  //used in WindowsMonitor Plugin
   sigc::signal<void, S2EExecutionState*, const ThreadDescriptor&> onThreadExit;    //used in WindowsMonitor Plugin
   sigc::signal<void, S2EExecutionState*, uint64_t> onProcessUnload; //used in WindowsMonitor Plugin
```
It also define the following virtual Functions:
```cpp
virtual bool getImports(S2EExecutionState *s, const ModuleDescriptor &desc, Imports &I) = 0;
virtual bool getExports(S2EExecutionState *s, const ModuleDescriptor &desc, Exports &E) = 0;
virtual bool isKernelAddress(uint64_t pc) const = 0;
virtual uint64_t getPid(S2EExecutionState *s, uint64_t pc) = 0;
virtual bool getCurrentStack(S2EExecutionState *s, uint64_t *base, uint64_t *size) = 0;
bool isOnTheStack(S2EExecutionState *s, uint64_t address); //which is use the prototype of getCurrentStacks() above.
```

<a name="ModuleTracer.cpp" />
## ModuleTracer.cpp

<a name="ModuleTracer.h" />
## ModuleTracer.h

Defined a `class ModuleTracer` which is inherited from `class EventTracer`, and `class ModuleTracerState`, 

<a name="ModuleDescriptor.h" />
## ModuleDescriptor.h

It define following maps:
```cpp
//Maps the name of the exported function to its actual address
typedef std::map<std::string,uint64_t> Exports;
  
//Maps the name of the function to its actual address
//XXX: Rename the type ImportedFunctions to ImportedSymbol.
typedef std::map<std::string, uint64_t> ImportedFunctions;
  
//Maps the library name to the set of functions it exports
typedef std::map<std::string, ImportedFunctions > Imports;
```
It also defines some section of Memory
```cpp
struct SectionDescriptor
{
    enum SectionType {
        READ=1, WRITE=2, READWRITE=3,
        EXECUTE=4
    };

    uint64_t loadBase;
    uint64_t size;
    SectionType type;
    std::string name;

    void setRead(bool b) {/* omit */}
    void setWrite(bool b) {/* omit */}
    void setExecute(bool b) {/* omit */}

    bool isReadable() const { return type & READ; }
    bool isWritable() const { return type & WRITE; }
    bool isExecutable() const { return type & EXECUTE; }
};
```
<a name=".cpp" />
## .cpp

<a name=".h" />
## .h

<a name="S2E.h"/>
## S2E.h

About 248 line of code, declare two data structure `struct S2EShared` for sych among multiple instances of S2E, and `class S2E` for initialize . The `struct S2EShared` is:

```cpp
//Structure used for synchronization among multiple instances of S2E
struct S2EShared {
    unsigned currentProcessCount;
    unsigned lastFileId;
    //We must have unique state ids across all processes
    //otherwise offline tools will be extremely confused when
    //aggregating different execution trace files.
    unsigned lastStateId;

    //Array of currently running instances.
    //Each entry either contains -1 (no instance running) or
    //the instance index.
    unsigned processIds[S2E_MAX_PROCESSES];
    unsigned processPids[S2E_MAX_PROCESSES];
    S2EShared() {
        for (unsigned i=0; i<S2E_MAX_PROCESSES; ++i)    {
            processIds[i] = (unsigned)-1;
            processPids[i] = (unsigned)-1;
        }
    }
};
```

The `S2E` maintain some variables and data structures for QUME. At this moment, I don't get into QEMU and LLVM. `S2E` member functions include: 
- `getConfig()`, 
- `getPlugin()`, 
- `getCorePlugin()`, 
- `getOutputDirectory()`, 
- `getOutputFilename()`, 
- `openOutputFile()`, 
- `getInfoStream()`, 
- `getDebugStream()`, 
- `getMessagesStream()`, 
- `getWarningStream()`, 
- `getExecutor()`, 
- `refreshPlugins()`, 
- `writeBitCodeToFile()`, 
- `fork()`, 
- `isForking()`, 
- `fetchAndIncrementStateID()`, 
- `fetchNextStable()`, 
- `getMaxProcesses()`, 
- `getCurrentProcessId()`, 
- `getCurrentProcessIndex()`, 
- `getProcessIndexForId()`, 
- `getCurrentProcessCount()`, 
- `checkDeadProcesses()`, 
- `getStartTime()`. 

Most of those member functions are for QEMU to call. Generally, it is the S2E API for QEMU. _The Plugins are talk to QEMU through S2E class._ 

<a name="S2E.cpp"/>
## S2E.cpp

Implementation of all the member functions that declared in the `S2E.h` file. We need to take a look at the `fork()` implementation. Nothing special until line 680, following is an exert from line 680 to line 709:

```cpp
        ...
        m_currentProcessIndex = newProcessIndex;
        //We are the child process, setup the log files again
        initOutputDirectory(m_outputDirectoryBase, 0, true);
        //Also recreate new statistics files
        m_s2eExecutor->initializeStatistics();
        //And the solver output
        m_s2eExecutor->initializeSolver();

        m_forking = true;

        qemu_init_cpu_loop(); /**  */
        if (main_loop_init()) {
            fprintf(stderr, "qemu_init_main_loop failed\n");
            exit(1);
        }

        if (init_timer_alarm(0)<0) {
            getDebugStream() << "Could not initialize timers" << '\n';
            exit(-1);
        }

        qemu_init_vcpu(env);
        cpu_synchronize_all_post_init();
        os_setup_signal_handling();
        vm_start();
        os_setup_post();
        resume_all_vcpus();
        vm_stop(RUN_STATE_SAVE_VM);

        m_forking = false;
        ...
```

The process run as a children process, so have todo some initialization in the begining. Then there are more QEMU functions called.

On the bottom of the file, there are a `extern "C" {}` block, which define some functions called from QEMU. Basically, those are wrapper functions to call the member functions defined in the `class S2E` class. For example, the following function definition:

```cpp
 S2E* s2e_initialize(int argc, char** argv,
            TCGLLVMContext* tcgLLVMContext,
            const char* s2e_config_file,  const char* s2e_output_dir,
            int verbose, unsigned s2e_max_processes)
{
    return new S2E(argc, argv, tcgLLVMContext,
                   s2e_config_file ? s2e_config_file : "",
                   s2e_output_dir  ? s2e_output_dir  : "",
                   verbose, s2e_max_processes);
}
```

It bascially return an initialized object to the caller.

On s2e_close, it first print a stack trace by calling the function ` print_stacktrace()`, which is defined at the begining of this file. Read the source of this function if you have time. I might be very valuable in implement this technique.

<a name="reference"/>
## References

[1. tsinghua.edu.cn](http://os.cs.tsinghua.edu.cn/oscourse/OS2012/projects/U03)
[2. Ucore_tool_s2e](https://github.com/chyyuu/ucore_tool_s2e)
[alienDetector]: https://developer.gnome.org/libsigc++-tutorial/2.2/ch02.html
