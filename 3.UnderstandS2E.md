S2E source code
===
####Table of contents:

- [How to Write an S2E plugin?](#HowtoS2EPlugin)
- [S2E.h](#S2E.h)
- [S2E.cpp](#S2E.cpp)
- [References](#reference)

<a name="HowtoS2EPlugin" />
## How to Write an S2E plugin

- Plugin - count how many times a specific instruction has been executed.
- configuration file - specify which instruction to watch.
- communication - with other plugins and expose reusable functionality.

The example gives the template for writing a plugin. Several things to understand:
1. Reading Configuration parameters
2. Register callback with signals

For 1. there is a code snippets that read the value from the configuration file.

```
//...

void InstructionTracker::initialize()
{
    m_address = (uint64_t) s2e()->getConfig()->getInt(getConfigKey() + ".addressToTrack");
}
```

Here noticed the `".addressToTrack"` string is the name of the configured value in the config file.

The way how signal and callback worked is explained in many places where this one I found very very useful [signal and slot](http://qt-project.org/doc/qt-5/signalsandslots.html). It is nothing special about signal and slot, they are just a advanced way of doing object communication, which was call typesafe callback. The following picture will show what they are and how they are works. 

![signals and slots illustration](http://qt-project.org/doc/qt-5/images/abstract-connections.png)

The slot is basically a callback function that is called when the signal emitted. Following a simple example to understand. Let's look at a very simple example about signal and slot in libsigc++ library. We want to write a application that inform users when an alien landed on car parking. We use libsigc++ to implement this application. There is a `AlienDetector` class needed. There is a signal defined in it. 

```cpp
class AlienDetector
{
public:
    AlienDetector();

    void run();

    sigc::signal<void> signal_detected;
};
```

I will also write another function `warn_people` which is called __slot__. 
```
void warn_people()
{
	cout << there is an alien in the carpark << endl;
}
```

Then the main function in this case is:
```
void main()
{
	AlienDetector myDetector;
	mydetector.signal_detected.connect(sigc::ptr_fun(warn_people));
	
	mydetector.run();
	
	return 0;
}
```

That's it!!! Please note the following sayings in the tutorial, it can help in understanding the concept of slot and metaprogramming. 

> Pretty simple really - you call the connect() method on the signal to connect your function. connect() takes a  slot parameter (remember slots are capable of holding any type of callback), so you convert your warn_people() function to a slot using the slot() function.
> 




_When a callback is connect to a core event, the function is ready to be called. For each of the signal, the call back will be involked, based on the if condition, it either do nothing or do somethin, in this case, it is increment the counter. _

###PluginState

The tutorial describe how to keep per-state plugin information in class `PluginState{}`. That is: the plugin works for each path independently. Two member function are needed. One for creating a new instance of the specific `PluginState` when s2e start symbolic execution. ???The other is a clone method that s2e used to fork plugin state when forking execution states during the execution. S2E automatically fork user code state when a new branch need to execute for the application, Plugin State have to be forked manually in the meantime by us.???



<a name="S2E.h"/>
## S2E.h

About 248 line of code, declare two data structure `struct S2EShared` for sych among multiple instances of S2E, and `class S2E` for initialize . The `struct S2EShared` is:

```cpp
//Structure used for synchronization among multiple instances of S2E
struct S2EShared {
    unsigned currentProcessCount;
    unsigned lastFileId;
    //We must have unique state ids across all processes
    //otherwise offline tools will be extremely confused when
    //aggregating different execution trace files.
    unsigned lastStateId;

    //Array of currently running instances.
    //Each entry either contains -1 (no instance running) or
    //the instance index.
    unsigned processIds[S2E_MAX_PROCESSES];
    unsigned processPids[S2E_MAX_PROCESSES];
    S2EShared() {
        for (unsigned i=0; i<S2E_MAX_PROCESSES; ++i)    {
            processIds[i] = (unsigned)-1;
            processPids[i] = (unsigned)-1;
        }
    }
};
```

The `S2E` maintain some variables and data structures for QUME. At this moment, I don't get into QEMU and LLVM. `S2E` member functions include: 
- `getConfig()`, 
- `getPlugin()`, 
- `getCorePlugin()`, 
- `getOutputDirectory()`, 
- `getOutputFilename()`, 
- `openOutputFile()`, 
- `getInfoStream()`, 
- `getDebugStream()`, 
- `getMessagesStream()`, 
- `getWarningStream()`, 
- `getExecutor()`, 
- `refreshPlugins()`, 
- `writeBitCodeToFile()`, 
- `fork()`, 
- `isForking()`, 
- `fetchAndIncrementStateID()`, 
- `fetchNextStable()`, 
- `getMaxProcesses()`, 
- `getCurrentProcessId()`, 
- `getCurrentProcessIndex()`, 
- `getProcessIndexForId()`, 
- `getCurrentProcessCount()`, 
- `checkDeadProcesses()`, 
- `getStartTime()`. 

Most of those member functions are for QEMU to call. Generally, it is the S2E API for QEMU. _The Plugins are talk to QEMU through S2E class._ 

<a name="S2E.cpp"/>
## S2E.cpp

Implementation of all the member functions that declared in the `S2E.h` file. We need to take a look at the `fork()` implementation. Nothing special until line 680, following is an exert from line 680 to line 709:

```cpp
        ...
        m_currentProcessIndex = newProcessIndex;
        //We are the child process, setup the log files again
        initOutputDirectory(m_outputDirectoryBase, 0, true);
        //Also recreate new statistics files
        m_s2eExecutor->initializeStatistics();
        //And the solver output
        m_s2eExecutor->initializeSolver();

        m_forking = true;

        qemu_init_cpu_loop(); /**  */
        if (main_loop_init()) {
            fprintf(stderr, "qemu_init_main_loop failed\n");
            exit(1);
        }

        if (init_timer_alarm(0)<0) {
            getDebugStream() << "Could not initialize timers" << '\n';
            exit(-1);
        }

        qemu_init_vcpu(env);
        cpu_synchronize_all_post_init();
        os_setup_signal_handling();
        vm_start();
        os_setup_post();
        resume_all_vcpus();
        vm_stop(RUN_STATE_SAVE_VM);

        m_forking = false;
        ...
```

The process run as a children process, so have todo some initialization in the begining. Then there are more QEMU functions called.

On the bottom of the file, there are a `extern "C" {}` block, which define some functions called from QEMU. Basically, those are wrapper functions to call the member functions defined in the `class S2E` class. For example, the following function definition:

```cpp
 S2E* s2e_initialize(int argc, char** argv,
            TCGLLVMContext* tcgLLVMContext,
            const char* s2e_config_file,  const char* s2e_output_dir,
            int verbose, unsigned s2e_max_processes)
{
    return new S2E(argc, argv, tcgLLVMContext,
                   s2e_config_file ? s2e_config_file : "",
                   s2e_output_dir  ? s2e_output_dir  : "",
                   verbose, s2e_max_processes);
}
```

It bascially return an initialized object to the caller.

On s2e_close, it first print a stack trace by calling the function ` print_stacktrace()`, which is defined at the begining of this file. Read the source of this function if you have time. I might be very valuable in implement this technique.

<a name="reference"/>
## References

[1. tsinghua.edu.cn](http://os.cs.tsinghua.edu.cn/oscourse/OS2012/projects/U03)
[2. Ucore_tool_s2e](https://github.com/chyyuu/ucore_tool_s2e)
